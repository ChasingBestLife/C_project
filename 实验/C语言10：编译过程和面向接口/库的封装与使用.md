# 库的封装与使用

## 1.库的基本概念

库是已经写好的、成熟的、可复用的代码，每个程序都需要依赖很多底层库

```
库可以简单看成一组目标文件的集合，将这些目标文件经过压缩打包之后形成一个文件。像在windows这样的平台上，最常用的C语言库是集成按开发环境所附带的运行库，这些库一般由编译厂商提供
```



## 2.windows下静态库创建和使用

### 2.1.静态库的创建（.lib）

1）VS：创建一个新项目，在已安装的模板中选择常规，在右边的类型选择“空项目”，在名称和解决方案中输入staticlib，点击确定

2）编写相关功能代码

3）在项目属性页中，配置属性 ——> 常规 ——> 配置类型 ——> 把应用程序.exe 修改成 静态库.lib

**4）**在项目名那，右键，点击**生成**，就生成成功了

​	具体位置看你的配置：比如你配置是x64位的Debug，那么文件就在x64目录的Debug下

5）调用：将lib文件放到项目中来，最好导入lib的**头文件**（方便用户查看功能）



### 2.2.静态库的优缺点

```
1）静态库对函数库的链接是放在编译时期完成的，静态库在程序的链接阶段被复制到了程序中，和程序运行的时候没有关系

2）程序在运行时与函数库再无瓜葛，移植方便
	在.exe生成程序时，已经把所有的静态库的东西放到程序上，即使你删掉现在静态库,打开exe也不影响功能使用
	
3）浪费空间和资源，所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件
	每一个.exe程序的内存空间，都会链接静态库文件，空间变大
	
4）更新困难，需要重新配一个全新的，重新运行一遍
```



## 3.windows下动态库创建和使用

```
要解决空间浪费和更新困哪这两个问题，最简单的办法就是把程序的模块相互分割开来，形成独立的文件，而不是将他们的静态库链接在一起。
简单来讲，就是不对哪些组程序的目标程序进行链接，等程序运行的时候才进行链接
```

也就是说，**把整个链接过程推迟到运行时再进行**，这就是动态库链接的基本思想

### 3.1.动态库的创建（.dll）

1）**外部函数的特殊声明**（静态库声明头文件的区别）
__declspec(dllexport) 

```
#在头文件.h中

#pragma once

// 默认函数声明 是用不了 ———— 内部函数只能在本项目文件使用
// int mySub(int a); 将这个函数称为内部函数

// 外部函数 需要特殊声明
__declspec(dllexport) int mySub(int a);
```

decl:声明		spec：特殊

dll：动态库	export：导出



2）在项目属性页中，配置属性 ——> 常规 ——> 配置类型 ——> 把应用程序.exe 修改成 动态库.dll

**3）**在项目名那，右键，点击**生成**，就生成成功了

​	具体位置看你的配置：比如你配置是x64位的Debug，那么文件就在x64目录的Debug下

#### 动态库生成.lib和.dll文件

```
动态库也会生成.lib文件，但是和静态库的不同

*静态库中的.lib文件会将所有函数声明、实现都放入其中

*动态库生成的.lib文件只会放导出函数的声明、和变量声明，具体的实现放在.dll文件中
```

### 3.2.动态库的使用

（有两种方法）：

#### 1）隐式调用

首先，直接把 **.dll** 和 **.lib** 文件和 **头文件.h**（方便用户使用）放进去项目目录中

然后在程序中指定链接引用链接库： **#pragma comment(lib, "./lib文件名.lib")**（"./" ——> 当前目录下找.lib文件）

```
为什么不放dll文件呢，因为lib文件存的是dll函数的声明，可以通过lib文件直接找到dll的函数的具体实现内容
```

#### 2）显式调用



### 3.3.动态库的优缺点

节省资源，更新发布简单





# 面向接口编程

与公司对接项目

```
/*介绍一下函数指针*/

// 函数指针
void (*INIT_GAME) (void** player, void* name);

void sub(void** player, void* name)
{
	具体功能
}

int main()
{
	INIT_GAME = &sub;
	(*INIT_GAME)(player, name);		// 调用
}

/*如果加typedef*/
typedef void (*INIT_GAME) (void** player, void* name);
---
int main()
{
	INIT_GAME p;	// 定义了一个void (*INIT_GAME) (void** player, void* name)类型的函数指针
}
```

