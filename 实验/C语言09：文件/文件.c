#include<stdio.h>



/*
设备文件 
在操作系统中把每一个与主机相连的输入、输出设备看作是一个文件，
把他们的输入、输出等同于对磁盘文件的读和写 
stdin：键盘 
stdout：屏幕 
其他

磁盘文件
存储外部介质，使用时才调入内存 



文本文件
存储时，是将字符的ASCII值存储在磁盘中，存的是ascii的二进制 ，
取的时候是将ascii转换成对应字符 

二进制文件
存的是二进制 ，取的是二进制 
*/


/*
文件
当打开一个文件时，系统会返回一个结构体，这个结构体有对此文件操作的所有信息 
当调用fopen时，系统返回这个结构体地址 
 
接口：API 	用：文件流指针 

打开文件 
fopen("pathfile", 打开方式) 
成功：返回FILE结构体的地址，失败返回NULL 

r	：只读（不创建文件）
w	：只写 （如果文件存在：先清空文件再写；不存在就相对路径创建一个）
r+	：可读可写（不创建文件）
w+	：可读可写可清空文件 
b	：二进制文件 
相对路径 
如果直接在vs中调试运行，相对路径相对的是工程文件
如果手动运行exe文件，相对路径相对的是可执行文件
 
 
当启动一个程序，系统自动打开3个设备文件
1.
键盘 ――》stdin（标准输入文件） ――》FILE* stdin = fopen(stdin,"r") 
fgets(buf, sizeof(buf), stdin)，根据stdin文件流指针，找到stdin文件，从里面获取
2.
FILE* stdout = fopen(stdout, "w") ――》stdout（标准输出文件） ――》终端 
3.
FILE* stdout = fopen（stderr, "w"） ――》stderr（标准错误文件） ――》终端
perror（""）;	输出错误函数 
*/


/*
获取文件状态
#include<sys/stat.h>
#include<sys/types.h> 
stat函数（），有文件，返回1；没有返回0 

struct stat *buf;	// 先定义一个stat类型的buf结构体 
					// 这个结构体不需要声明，因为头文件已经有了，	
					// 而且这个结构体是上面说的结构体 
stat(const char* path, struct stat *buf)
*/


/*
\r是回车，英文是Carriage return，作用：使光标到行首
\n是换行，英文是New line/line feed，作用：使光标下移一行

windows存储"\n"：\n	――》 \r\n；取出:\r\n ――》\n 

Linux存储"\n"：\n ――》 \n 
*/

/*
文件缓冲区 
每一个正在使用的文件，操作系统都会为其在内存中开辟一块区域，称之为：文件缓冲区。
每当我们想从内存向硬盘中输出数据，都会先将数据输送到缓冲区中，
然后装满缓冲区后才一起输送到硬盘上。如果想从硬盘向计算机内读入数据，
则会先将读到的数据输送到缓冲区中，装满缓冲区后再逐个将数据输送到程序数据区（内存中的变量）

将字符写入文件，调用系统调用，进入内核，需要消耗资源和时间 
文件缓冲区在写文件的时候提高整个操作系统的效率，在读文件的时候提高了程序的效率。

刷新缓冲区（64k内存）：即将缓冲区的文件全部写入文件 
3种
当内容满了 
调用fflush（） ，强制刷新
程序正常退出 
*/
int main()
{
	fopen("./a.txt", "r");	// 前面的./是指在当前文件的目录下 ，如果直接在vs中调试运行，相对路径相对的是工程文件
							// 如果手动运行exe文件，相对路径相对的是可执行文件 
	return 0;
} 
